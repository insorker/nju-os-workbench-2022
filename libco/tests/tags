!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
INIT_LIST_HEAD	co-test.h	32;"	d
Item	co-test.h	/^} Item;$/;"	t	typeref:struct:Item_t
Item_t	co-test.h	/^typedef struct Item_t {$/;"	s
LIST_HEAD	co-test.h	29;"	d
LIST_HEAD_INIT	co-test.h	27;"	d
Queue	co-test.h	/^} Queue;$/;"	t	typeref:struct:Queue_t
Queue_t	co-test.h	/^typedef struct Queue_t {$/;"	s
__list_add	co-test.h	/^static inline void __list_add(struct list_head *new,$/;"	f
__list_del	co-test.h	/^static inline void __list_del(struct list_head *prev, struct list_head *next)$/;"	f
__list_splice	co-test.h	/^static inline void __list_splice(struct list_head *list,$/;"	f
add_count	main.c	/^static void add_count() {$/;"	f	file:
cap	co-test.h	/^    int cap;$/;"	m	struct:Queue_t
consumer	main.c	/^static void consumer(void *arg) {$/;"	f	file:
data	co-test.h	/^    void *data;$/;"	m	struct:Item_t
do_consume	main.c	/^static void do_consume(Queue *queue) {$/;"	f	file:
do_produce	main.c	/^static void do_produce(Queue *queue) {$/;"	f	file:
g_count	main.c	/^int g_count = 0;$/;"	v
g_running	main.c	/^static int g_running = 1;$/;"	v	file:
get_count	main.c	/^static int get_count() {$/;"	f	file:
link	co-test.h	/^    struct list_head link;$/;"	m	struct:Item_t	typeref:struct:Item_t::list_head
list	co-test.h	/^    struct list_head list;$/;"	m	struct:Queue_t	typeref:struct:Queue_t::list_head
list_add	co-test.h	/^static inline void list_add(struct list_head *new, struct list_head *head)$/;"	f
list_add_tail	co-test.h	/^static inline void list_add_tail(struct list_head *new, struct list_head *head)$/;"	f
list_del	co-test.h	/^static inline void list_del(struct list_head *entry)$/;"	f
list_del_init	co-test.h	/^static inline void list_del_init(struct list_head *entry)$/;"	f
list_empty	co-test.h	/^static inline int list_empty(struct list_head *head)$/;"	f
list_entry	co-test.h	192;"	d
list_for_each	co-test.h	200;"	d
list_for_each_entry	co-test.h	228;"	d
list_for_each_entry_safe	co-test.h	240;"	d
list_for_each_prev	co-test.h	208;"	d
list_for_each_safe	co-test.h	218;"	d
list_head	co-test.h	/^struct list_head {$/;"	s
list_move	co-test.h	/^static inline void list_move(struct list_head *list, struct list_head *head)$/;"	f
list_move_tail	co-test.h	/^static inline void list_move_tail(struct list_head *list,$/;"	f
list_splice	co-test.h	/^static inline void list_splice(struct list_head *list, struct list_head *head)$/;"	f
list_splice_init	co-test.h	/^static inline void list_splice_init(struct list_head *list,$/;"	f
main	main.c	/^int main() {$/;"	f
next	co-test.h	/^	struct list_head *next, *prev;$/;"	m	struct:list_head	typeref:struct:list_head::list_head
prev	co-test.h	/^	struct list_head *next, *prev;$/;"	m	struct:list_head	typeref:struct:list_head::
producer	main.c	/^static void producer(void *arg) {$/;"	f	file:
q_free	co-test.h	/^static inline void q_free(Queue *queue) {$/;"	f
q_is_empty	co-test.h	/^static inline int q_is_empty(Queue *queue) {$/;"	f
q_is_full	co-test.h	/^static inline int q_is_full(Queue *queue) {$/;"	f
q_new	co-test.h	/^static inline Queue* q_new() {$/;"	f
q_pop	co-test.h	/^static inline Item* q_pop(Queue *queue) {$/;"	f
q_push	co-test.h	/^static inline void q_push(Queue *queue, Item *item) {$/;"	f
sz	co-test.h	/^    int sz;$/;"	m	struct:Queue_t
test_1	main.c	/^static void test_1() {$/;"	f	file:
test_2	main.c	/^static void test_2() {$/;"	f	file:
work	main.c	/^static void work(void *arg) {$/;"	f	file:
work_loop	main.c	/^static void work_loop(void *arg) {$/;"	f	file:
